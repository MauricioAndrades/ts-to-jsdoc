#! /usr/bin/env node
const transpile = require("../index.js");
const fs = require("fs");
const path = require("path");

const args = require("arg")({
  "--out": String,
  "-o": "--out",
  "--output": "--out",

  "--ignore": [String],
  "-i": "--ignore",

  "--help": Boolean,
  "-h": "--help",
});
args.out = args["--out"];
args.ignore = args["--ignore"];
args.help = args["--help"];

const help = `
Usage:
  ts-to-jsdoc [options] <path>...

Options:
  -h --help          Shows this.
  -o --out --output  Directory to output transpiled JavaScript. [default: source path]
  -i --ignore        File or directory paths to ignore when transpiling.`;

if (args.help || Object.keys(args).every((arg) => !args[arg]?.length)) {
  console.log(help);
  process.exit(0);
}

if (args.out) {
  args.out = makePathAbsolute(args.out);
  if (!fs.existsSync(args.out)) {
    console.error(error(`Output directory ${args.out} does not exist.`));
    process.exit(1);
  }
  if (!fs.lstatSync(args.out).isDirectory()) {
    console.error(error(`Output directory ${args.out} is not a directory.`));
    process.exit(1);
  }
}

args.ignore = args.ignore?.length ? normalizePaths(args.ignore) : [];

const paths = replaceDirectoriesWithFiles(
    [...new Set(normalizePaths(args._))], // Creating a Set then spreading removes duplicates
)
    .filter((filepath) => path.extname(filepath) === ".ts" && !filepath.endsWith(".d.ts"))
    .filter((filepath) =>
      !args.ignore.some(
          (ignoredPath) => filepath === ignoredPath || require("path-is-inside")(filepath, ignoredPath),
      ),
    );

for (const filepath of paths) {
  const outPath = path.join(
      args.out ?? path.dirname(filepath),
      `${path.basename(filepath, ".ts")}.js`,
  );
  if (fs.existsSync(outPath)) {
    console.warn(warning(`Cannot write to ${outPath}; file already exists.`));
    continue;
  }

  const code = fs.readFileSync(filepath, "utf8");
  const transpiled = transpile(code, filepath, {}, true);
  if (transpiled === code) {
    console.error(error(`Could not transpile ${filepath}.`));
    continue;
  }

  fs.writeFileSync(outPath, transpiled);
}

function warning(message) {
  return `\u001B[93m[WARN]\u001B[39m ${message}`;
}

function error(message) {
  return `\u001B[91m[ERROR]\u001B[39m ${message}`;
}

function makePathAbsolute(filepath) {
  return path.isAbsolute(filepath) ?
    filepath :
    path.resolve(process.cwd(), filepath);
}

/**
 * Makes paths absolute, filtering those that exist
 * @param {Array<string>} paths An array of paths
 * @return {Array<string>} An array containing absolute paths that do exist
 */
function normalizePaths(paths) {
  return paths
      .map(makePathAbsolute)
      .filter((filepath) => {
        if (!fs.existsSync(filepath)) {
          console.warn(warning(`File or directory ${filepath} does not exist.`));
          return false;
        }
        return true;
      });
}

/**
 * Given an array of paths, recursively removes all directories and appends all files within said directories
 * @param {Array<string>} paths An array of paths
 * @return {Array<string>} An array containing only files, replacing directories with their contents
 */
function replaceDirectoriesWithFiles(paths) {
  let pathArray = [...paths];
  for (const [index, filepath] of pathArray.entries()) {
    if (fs.existsSync(filepath) && fs.lstatSync(filepath).isDirectory()) {
      pathArray.splice(index, 1);
      pathArray = pathArray
          .concat(replaceDirectoriesWithFiles(
              fs.readdirSync(filepath).map((file) => path.join(filepath, file)),
          ));
    }
  }
  return pathArray;
}
